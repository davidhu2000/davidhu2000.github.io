---
layout: "../../layouts/BlogPost.astro"
title: "How I Structure My Terraform Code"
description: "Infrastructure as code is awesome! Here's how I utilize it"
pubDate: "2022-09-26"
heroImage: "./src/assets/blog/how-i-structure-my-terraform-code/hero-image.jpg"
tags: ["technologies", "infrastructure"]
---

As a quick TLDR, Terraform allows me to write code to create infrastructure. So instead of

1. Open cloud provider UI
2. click 10-15 buttons
3. click Create
4. make sure to remember how to do this later by writing a doc somewhere

We can just run `terraform plan` to see what changes will be made, and `terraform apply` to make the changes.

The HashiCorp [docs](https://www.terraform.io/docs#terraform-documentation) does a great job of explaining this deeper.

## How do I use terraform?

Great question! I generally prefer 2 layers of abstractions

- The first layer is creating a module that creates all the necessary resources you'd need but with tons of inputs to allow you to adjust the resource configurations for your specific needs.
- Second layer is based on different environments I'm working in, like staging vs production. This layer is a wrapper around the first layer that hardcodes most of the configuration options outside a few that need to be different across environments, such as tags.

Then, I call the second layer module on each environment.

Now, enough words, let's show some code.

For our example, (I will mostly be using fake resources to demo), we want to create an API service with 3 servers, a database, and a load balancer. Let's say this is the template we use for all of our API services. In pseudocode, we would roughly need something like the below to achieve this result.

```hcl
resource "load_balancer" "my_load_balancer" {
  name = "my-service-load-balancer"
  env  = "staging"
}

resource "server" "my_server" {
  count         = 3
  size          = "md"
  load_balancer = load_balancer.my_load_balancer.name
  env           = "staging"
}

resource "database" "my_database" {
  name     = "my-database"
  username = "app-user"
  password = "topsecretnoonewillknow"
  engine   = "mysql"
  size     = "large"
  env      = "staging"
}
```

This works fine until everyone sees your terraform and says I want the same. Do we just copy it? Or, we can create a terraform module to abstract the code so others can use it easily. Now that we want the whole company to use our terraform, we need to make it more generic: meaning we take most of the inputs and allow them as arguments for our module.

As an example, the `load_balancer` code from above will become:

```hcl
resource "load_balancer" "my_load_balancer" {
  name = var.load_balancer_name
  env  = var.env
}
```

And we just create a `variables.tf` in the same module directory

```hcl
variables "env" {
  type        = "string"
  description = "Environment of the application"
}

variables "load_balancer_name" {
  type        = "string"
  description = "The name of the load balancer"
}
```

This creates the first layer of abstractions. The code we need to write in the application will now look like

```hcl
module "api_service" {
  source = "github.com/my-company/terraform-modules/api_service"

  env         = "staging"
  name        = "my-load-balancer"
  server_size = "md"
  db_name     = "my-database"
  db_size     = "large"
  db_user     = "my-db-user"
  db_password = "thisisnotverysecret"
}
```

See, way less code especially if we need to do this over and over again.

Moving onto the 2nd layer, because the terraform module is written to be more generic, and our application has specific needs, we would create another module within our app repo that will look almost identical to the code block above, where we hardcode most of the inputs and leave off a couple to differentiate between environments.

```hcl
# terraform/modules/my-service/main.tf
module "api_service" {
  source = "github.com/my-company/terraform-modules/api_service"

  env         = var.env
  name        = "my-load-balancer"
  server_size = "md"
  db_name     = "my-database"
  db_size     = "large"
  db_user     = "my-db-user"
  db_password = var.db_password
}
```

The only variables we need to pass in are `env` and `db_password` when creating infrastructure for each env. This helps make sure different environments are as closely matched as possible. Here is the code for both staging and prod

```hcl
# terraform/env/staging/main.tf
module "api_service" {
  source = "../modules/my-service"

  env         = "staging"
  db_password = "staging-password"
}

# terraform/env/prod/main.tf
module "api_service" {
  source = "../modules/my-service"

  env         = "prod"
  db_password = "prod-password"
}
```

To summarize how the modules are setup,

```
# module repo
├── main.tf
├── variables.tf

# app repo
|-- terraform
|-- env
│   ├── staging
│   │   ├── main.tf
│   ├── prod
│   │   ├── main.tf
├── modules/
│   ├── my-service/
│   │   ├── variables.tf
│   │   ├── main.tf
```

### Quick Tip: how to terraform if you don't know what inputs you need to change

Start with making a change in the cloud provider UI. Then run a plan in terraform, which will detect the difference, now just change the input that that code shows and run a new plan to see that terraform now says no changes.
